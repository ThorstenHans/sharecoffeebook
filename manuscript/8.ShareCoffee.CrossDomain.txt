#ShareCoffee.CrossDomain

When building Provider Hosted Apps for SharePoint, most samples on MSDN are demonstrating how to communicate with SharePoint or Office 365 using server-side code either in Code-Behind files for ASP.NET WebForms or code located in controllers when talking about ASP.NET MVC. Using C# CSOM for communicating with SharePoint is common, but not the best choice for all the requirements. In these days users are considering fancy web applications, using client-side logic in order to make interactions fluent and smooth. SharePoint is offering a CrossDomain library for communication from such Provider Hosted Apps using JavaScript.

In order to get CrossDomain support for REST queries working, you've to reference a JavaScript file from the HostWeb. (You'll that later in this chapter). As soon as all the required scripts are loaded and referenced within your website, you've to use an instance of `SP.RequestExecutor` which is responsible for communicating with SharePoint's REST interface.

SP.RequestExecutor is injecting an hidden IFrame to your website. This hidden IFrame will load an ASPX page from your HostWeb which is responsible for handling all the CrossDomain requests by relying on HTML Post Messages. For you as an App developer, you've to use SP.RequestExecutor instances for executing REST requests in those scenarios.

## Manually activating CrossDomain Support for REST

As mentioned in the introduction, you've to reference the `SP.RequestExecutor.js` file from your HostWeb. The entire path to the script can be constructed like this:

`{SPHostUrl}/_layouts/15/SP.RequestExecutor.js`


## Activating CrossDomain Support for REST with ShareCoffee

ShareCoffee is abstracting this manual task. You can use `ShareCoffee.CrossDomain.loadCrossDomainLibrary()` for loading the `SP.RequestExecutor.js` file from the HostWeb. If you're interested in, you can provide callbacks for success and failure to `loadCrossDomainLibrary` as shown in the next code sample.

    var onLoaded = function(){
        console.log("SharePoint's CrossDomain Library for REST loaded");

        goAndReadDataFromTheAppWeb();
        goAndReadDataFromTheHostWeb();
    };

    var onErrorLoading = function(){
        console.log("Ouch! Something wen't wrong, can't load CrossDomain Library");
    };

    ShareCoffee.CrossDomain.loadCrossDomainLibrary(onLoaded, onErrorLoading);

## Detecting if CrossDomain Library is already loaded

ShareCoffee is internally tracking if it was able to load the CrossDomain library. Beside tracking this information, you can also use this property witihn your code. You can access this property by using

`ShareCoffee.CrossDomain.crossDomainLibrariesLoaded`


## CrossDomain CRUD Operations

As for plain REST requests is ShareCoffee also offering a fluent API for executing all the various CRUD operations in a CrossDomain environment.

    ShareCoffee.CrossDomain.build.create
    ShareCoffee.CrossDomain.build.read
    ShareCoffee.CrossDomain.build.update
    ShareCoffee.CrossDomain.build.delete

Because you've to use SPRequestExecutor in order to commuicate succesfully with SharePoint, there is only a single API available from this point

    ShareCoffee.CrossDomain.build.create.for.SPCrossDomainLib();
    ShareCoffee.CrossDomain.build.read.for.SPCrossDomainLib();
    ShareCoffee.CrossDomain.build.update.for.SPCrossDomainLib();
    ShareCoffee.CrossDomain.build.delete.for.SPCrossDomainLib();

T> ## IE 8 workaround
T> IE8 is supported by SharePoint 2013 OnPremise, if you're targeting this browser, you've to replace the **for** property by the **f** shorthand.
T> IE9 is not able to execute a function or access a proprety called **for**

## Providing REST Properties

Passing properties for CrossDomain REST requests is exactly the same as for plain REST requests. So you don't have to learn anything new. Remeber, either you can pass a plain JSON object or you can use an instance of `ShareCoffee.REST.RequestProperties`.

## HostWeb Access for CrossDomain REST queries

When browsing MSDN for CrossDomain REST requests which should target the HostWeb, you may stumble upon urls that look like the following

`{SPAppWebUrl}/_api/SP.AppContextSite(@target)/web/lists/GetByTitle('Tasks')/items?@target={SPHostUrl}`

which would be way to complicated to construct manually or remember over a timespan for more than a few hours. ShareCoffee is abstracting this for all REST queries where it's required. Once again, also when running CrossDomain, the worst and most verbose configuration would look similar to this

    ShareCoffee.CrossDomain.build.create.for.SPCrossDomainLib({
        url: "web/lists/GetByTitle('Tasks')/items",
        payload: listItemInfo,
        hostWebUrl: ShareCoffee.Commons.getHostWebUrl()
        onSuccess: function(data){},
        onError: function(data){}
    });

Compared to frameworks as jQuery, AngularJS or reqwest, SP.RequestExecutor isn't offering a chained API for handling request callbacks. Therefor it's required to provide those callbacks using the options object. 

## Execute CrossDomain queries with SP.RequestExecutor

The only missing piece right here is how to use `SP.RequestExecutor`. It's offering a simple handy API which makes executing REST calls in CrossDomain scenarios easy.

    var e = new SP.RequestExecutor(ShareCoffee.Commons.getAppWebUrl());
    var onListsLoaded = function(data){
      // process lists
    };
    var options = {
      url: 'web/lists/?$select=Id,Title',
      onSuccess: onListsLoaded,
      onError: function(data, code, errorMessage){
        console.log("Error " + code + ": " + errorMessage);
      }
    };
    
    e.executeAsync(ShareCoffee.CrossDomain.build.read.for.SPCrossDomainLib(options));