#ShareCoffee.REST

Finally SharePoint 2013 is offering an OData conform REST API. The new REST API allows developers to consume SharePoint data or consume SharePoint's services. Compared to SharePoint 2010's REST(ish) `ListData.svc` service, most of the OData URL query operations are also supported to filter, limit or sort data returned from all the REST endpoints.

As mentioned in the **About ShareCoffee** chapter, developers have to reconfigure their REST requests, when contextual changes are made. (Move targeting lists from the AppWeb to the HostWeb or convert a SharePoint-Hosted App to a Provider-Hosted App for example).

On top of those contextual changes that may impact the code you've to write, developers also have to remember different configuring approaches for actually building the REST requests using their preferred AJAX components. 
I>##Supported Libraries
I>Numerous JavaScript frameworks are offering AJAX wrappers in order to take away the pain of I>manually building HTTP(S) requests. **ShareCoffee is currently supporting the following libraries**
I>  * jQuery
I>  * AngularJS
I>  * reqwest

In order to get started, let’s assume take a simple HTTP-GET sample, which will read some list-metadata from the HostWeb. The upcoming code snippets will show how to build exactly the same request. The first snippet demonstrates how to read this information using plain jQuery.

<<[Get List-Metadata with jQuery only](code/rest/jquery.js)

It’s important to specify all those properties when using SharePoint’s REST API. Ignoring one of the properties may result in an internal server error instead of returning the data you’re interested in.
Now let’s review the same request but instead of using plain jQuery, ShareCoffee is utilized to take away most of the work from you.

<<[Get List-Metadata with ShareCoffee and jQuery](code/rest/jquery-sharecoffee.js)

ShareCoffee is **NOT** another AJAX wrapper. It is more a factory which is responsible for configuring REST requests that perfectly fit in all situations. That means in detail that ShareCoffee is responsible for providing all the HTTP-Headers required for the request you’d like to execute.

## Note on Provider-Hosted Apps with READ operations
SharePoint is validating each and every request in order to validate if the origin is trusted. To do so, SharePoint is validating the Form-Request-Digest (a code generated by SharePoint). In SharePoint-Hosted Apps, ShareCoffee is able to extract this value from the current MasterPage. Unfortunately this isn’t possible in Provider-Hosted Apps. For Provider-Hosted Apps, you’ve to specify how ShareCoffee should load this value. [See this blog post, which describes in detail how to achieve this]( http://dotnet-rocks.com/2014/01/28/query-formdigestvalue-from-sharepoint-using-sharecoffee/)


`ShareCoffee.REST.build` is the global entry-point for creating REST properties. Depending on your intent, you can choose one of the following operations

  * Create
  * Read
  * Update
  * Delete

which are reflecting the famous CRUD operations. 

    ShareCoffee.REST.build.create
    ShareCoffee.REST.build.read
    ShareCoffee.REST.build.update
    ShareCoffee.REST.build.delete


In order to support all the following JavaScript frameworks

  * jQuery
  * AngularJS
  * reqwest

You've to specify which framework you're currently using, prefixed by the `for` property

    // AngularJS samples
    ShareCoffee.REST.build.create.for.angularJS();
    ShareCoffee.REST.build.read.for.angularJS();
    ShareCoffee.REST.build.update.for.angularJS();
    ShareCoffee.REST.build.delete.for.angularJS();

    // jQuery samples
    ShareCoffee.REST.build.create.for.jQuery();
    ShareCoffee.REST.build.read.for.jQuery();
    ShareCoffee.REST.build.update.for.jQuery();
    ShareCoffee.REST.build.delete.for.jQuery();

    // reqwest samples
    ShareCoffee.REST.build.create.for.reqwest();
    ShareCoffee.REST.build.read.for.reqwest();
    ShareCoffee.REST.build.update.for.reqwest();
    ShareCoffee.REST.build.delete.for.reqwest();

T> ## IE 8 workaround
T> IE8 is supported by SharePoint 2013 OnPremise, if you're targeting this browser, you've to replace the **for** property by the **f** shorthand.
T> IE9 is not able to execute a function or access a proprety called **for**


## Providing REST Properties

Now you've seen ShareCoffee's entire API, there is only one thing missing : The REST operation configuration. ShareCoffee is providing some cool features, which will help you building exactly these configurations.

There are two different ways how those properties can be created

  * using `ShareCoffee.REST.RequestProperties` object
  * using a plain JSON object

`ShareCoffee.REST.RequestProperties` is exposing all the properties that could be used to configure REST requests. Those properties are

|Property|Task / Used for|
|--------|---------------|
|url|describes the requested resource|
|payload|used for create and update requests for specifying the resource|
|hostWebUrl|used when accessing resources from the HostWeb|
|eTag|used for Update or Delete queries to deal with concurrency|
|onSuccess|can be used to store success callback|
|onError|can be used to store error callback|

You can create a new instance from `RequestProperies` using the existing constructor


    var options = new ShareCoffee.REST.RequestProperties(
      url, 
      payload,
      hostWebUrl, 
      eTag, 
      onSuccess, 
      onError
    );

The second option is using a plain JSON object. **Ensure that property names are matching the property names from `ShareCoffee.REST.RequestProperties`**.

    var options = {
      url: 'web',
      hostWebUrl: ShareCoffee.Commons.getHostWebUrl()
    };

Let's start with a simple example (All the samples assume that you're using jQuery). Let's say you'd like to read all the ContentTypes available on the AppWeb. So by definition it's a **read** operation, ContentTypes are available on web level, so we have to build a REST query which pulls out the ContentTypes from

`https://myapp.foo.sharepoint.com/sites/bar/MyApp/_api/web/ContentTypes`

    var options = {
      url: 'web/ContentTypes'
    };
    $.ajax(ShareCoffee.REST.build.read.for.jQuery(options))
    .done(onSuccess)
    .fail(onError);

In the sample code above we've only specified a part of the entire url, this is working because ShareCoffee is internally concatting the url you provide to 

`ShareCoffee.Commons.getApiRootUrl()`. Beside this, ShareCoffee knows that you're executing a GET query and working on the AppWeb, so it's able to extend the HTTP Request by all the headers required to successfully executing such a read operation against the AppWeb. The sample above can also be writtin like this

    $.ajax(ShareCoffee.REST.build.read.for.jQuery({
      url: 'web/ContentTypes'
    })).done(onSuccess).fail(onError);

    // even shorter by using the ShareCoffee shorthand
    $.ajax($s.REST.build.read.for.jQuery({
      url: 'web/ContentTypes'
    })).done(onSuccess).fail(onError);


A little bit more complicated as reading is creating items using the REST API. For this example, assume that you've to create a new list on your AppWeb using SharePoint's REST API. In order to do so, you've to provide a descriptive object which tells SharePoint what to create.

    var listInfo = {
      '__metadata' : {'type': 'SP.List'},
      'AllowContentTypes': true,
      'BaseTemplate': 100,
      'ContentTypesEnabled': true,
      'Title': 'My REST List',
      'Description': 'This list has been created by ShareCoffee'
    };

    // execute the REST call and pass the listInfo as payload
    $.ajax(ShareCoffee.REST.build.create.for.jQuery({
      url: 'web/lists/',
      payload: listInfo
    })).done(onSuccess).fail(onError);

Updating the list we've just created is also very straight forward. you've to pass the properties you like to change as payload.

    var updateListInfo = {
      '__metadata': {'type': 'SP.List'},
      'Title': 'My Buying List'
    };

    // execute the REST call and pass the updateListInfo as payload
    $.ajax(ShareCoffee.REST.build.update.for.jQuery({
      url: "web/lists/GetById('581aecc9-b365-46f0-83bd-6e002d96d7ce')",
      payload: updateListInfo
    })).done(onSuccess).fail(onError);

Deleting the list you've just created is also very easy just use the delete property and specify the url you've used for updating the list.

    $.ajax(ShareCoffee.REST.build.delete.for.jQuery({
      url: "web/lists/GetById('581aecc9-b365-46f0-83bd-6e002d96d7ce')"
    })).done(onSuccess).fail(onError);


## Using ShareCoffee.REST for HostWeb Access

Accessing data from the HostWeb instead of the AppWeb would result in huge changes that you've to make when you aren't using ShareCoffee. With ShareCoffee this is pretty easy. You've just to add the `hostWebUrl` parameter to your REST request properties.

T> ## Don't forget the permissions
T> When accessing resources from the HostWeb, you've to explicitly request permissions for those resources. If you're not aware of permissions for SharePoint Apps, review Chapter 1, there is a dedicated section on SharePoint App Permissions.

### Creating a List on the HostWeb

    var listInfo = {
      '__metadata' : {'type': 'SP.List'},
      'AllowContentTypes': true,
      'BaseTemplate': 100,
      'ContentTypesEnabled': true,
      'Title': 'My REST List',
      'Description': 'This list has been created by ShareCoffee'
    };

    // execute the REST call and pass the listInfo as payload
    $.ajax(ShareCoffee.REST.build.create.for.jQuery({
      url: 'web/lists/',
      hostWebUrl: ShareCoffee.Commons.getHostWebUrl(), 
      payload: listInfo
    })).done(onSuccess).fail(onError);


### Updating a List on the HostWeb

    var updateListInfo = {
      '__metadata': {'type': 'SP.List'},
      'Title': 'My Buying List'
    };

    // execute the REST call and pass the updateListInfo as payload
    $.ajax(ShareCoffee.REST.build.update.for.jQuery({
      url: "web/lists/GetById('581aecc9-b365-46f0-83bd-6e002d96d7ce')",
      hostWebUrl: ShareCoffee.Commons.getHostWebUrl(), 
      payload: updateListInfo
    })).done(onSuccess).fail(onError);

### Reading List Information from the HostWeb

    $.ajax(ShareCoffee.REST.build.read.for.jQuery({
      url: "web/Lists/GetById('581aecc9-b365-46f0-83bd-6e002d96d7ce')",
      hostWebUrl: ShareCoffee.Commons.getHostWebUrl()
    })).done(onSuccess).fail(onError);


### Deleting the List form the HostWeb

    $.ajax(ShareCoffee.REST.build.delete.for.jQuery({
      url: "web/lists/GetById('581aecc9-b365-46f0-83bd-6e002d96d7ce')",
      hostWebUrl: ShareCoffee.Commons.getHostWebUrl()
    })).done(onSuccess).fail(onError);


As you can see, you don't have to make many changes in order to move queries targeting the AppWeb to the HostWeb. This is a huge advantage of ShareCoffee. In real customer driven projects it's not uncommon that you've to make exactly this change during development time. Lists which are hosted on the AppWeb provide less functionality as "traditional" lists (which are located on HostWebs). 


## JSONLight support in Office365

In August 2014, Microsoft announced the general availability of JSONLight support for SharePoint Online's REST API. JSONLight support is also backed into ShareCoffee. 

W> ## Currently no OnPremise support
W> When writing this book, there were no information on JSONLight support for SharePoint 2013 OnPremise. 

ShareCoffee 0.1.1 is offering an easy way to change REST response style from the default `odata=verbose` to one of the following

  * minimal `odata=minimalmetadata`
  * no metadata `odata=nometadata`

ShareCoffee is exposing a single property which will control this for all the queries you're executing.

    ShareCoffee.jsonRequestBehavior

`ShareCoffee.jsonRequestBehavior` is defaulting to `odata=verbose` which will also work for all SharePoint OnPremise installations.

See the short sample below, which demonstrates how to use 

`ShareCoffee.JsonRequestBehaviors` object in order to change the behavior easily

    ShareCoffee.jsonRequestBehavior = 
        ShareCoffee.JsonRequstBehaviors.minimal;
    // all requests will send odata=minimalmetadata as Accept header

    ShareCoffee.jsonRequestBehavior = 
        ShareCoffee.JsonRequstBehaviors.nometadata;
    // all requests will send odata=nometadata as Accept header

    ShareCoffee.jsonRequestBehavior = 
        ShareCoffee.JsonRequstBehaviors.verbose;
    // all requests will send odata=verbose as Accept header

    ShareCoffee.jsonRequestBehavior = 
        ShareCoffee.JsonRequstBehaviors.default;
    // all requests will send odata=verbose as Accept header


See [this article on blogs.office.com](http://blogs.office.com/2014/08/13/json-light-support-rest-sharepoint-api-released/) which describes how REST responses will reflect this setting.
    